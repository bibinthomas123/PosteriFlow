# ========================= AHSD: Adaptive Hierarchical Signal Decomposition =========================
# Complete PriorityNet training configuration with all validated parameters
# Updated: 2025-11-10

experiment_name: "AHSD_Phase2_PriorityNet"
random_seed: 420
device: "auto"

# ==============================================================================
# TRAINING STAGE & COMPONENT CONFIGURATION (Nov 14, 2025)
# ==============================================================================
stage: "1B"                                 # Stage 1B: RL controller training (PriorityNet frozen)
                                             # Stage 1B: RL controller training (PriorityNet frozen)
                                             # Stage 1C: Joint fine-tuning (all components trained)

components:
  priority_net: true                        # ⊘ DISABLED in Stage 1A (enables in 1B+)
  context_encoder: true                      # ✅ TRAINING: Context encoding for flow
  normalizing_flow: true                     # ✅ TRAINING: Flow-based posterior estimation
  bias_corrector: true                       # ✅ TRAINING: Systematic error correction
  uncertainty_estimator: true                # ✅ TRAINING: Confidence calibration
  rl_controller: true                       # ⊘ INACTIVE in Stage 1A (activates in 1B)
  adaptive_subtractor: true                 # ⊘ UNUSED: Signal subtraction (future)

# ==============================================================================
# PRIORITY NET CONFIGURATION (Core model parameters)
# ==============================================================================
priority_net:
  
  # --- ARCHITECTURE ---
  hidden_dims: [640, 512, 384, 256]      # ✅ Increased from [512, 384, 256, 128]
  dropout: 0.25                           # Dropout in priority head
  importance_hidden_dim: 32               # Cross-signal importance network hidden dim (must match checkpoint)
  
  # --- MODEL FLAGS ---
  use_strain: true                       # Enable temporal strain encoder
  use_edge_conditioning: true            # Enable edge-type embedding
  n_edge_types: 19                        # Number of edge case types
  use_transformer_encoder: false          # ✅ Use Transformer encoder (Whisper+adapter, 1.5x faster, better accuracy)
  
  # --- OPTIMIZER ---
  optimizer: "AdamW"
  learning_rate: 3.0e-5
  weight_decay: 1.5e-5
  
  # --- TRAINING SCHEDULE ---
  batch_size: 32                          # ⬆️ Increased from 6 (larger batch → stable BatchNorm)
  epochs: 40
  patience: 15                            
  
  # --- WARMUP ---
  warmup_epochs: 6
  warmup_start_factor: 0.02
  
  # --- LEARNING RATE SCHEDULER ---
  scheduler: "ReduceLROnPlateau"
  scheduler_patience: 7
  scheduler_factor: 0.5
  scheduler_threshold: 5e-3
  min_lr: 1.0e-6
  
  # --- LOSS FUNCTION ---
  # TUNING METHODOLOGY (Nov 10-15, 2025):
  #   Multi-objective balancing for signal prioritization with 5 test blocks:
  #   - Block 1-3 (Ranking, MSE, Consistency): Pairwise signal ordering
  #   - Block 4 (Calibration): Output dynamic range expansion
  #   - Block 5 (Uncertainty): Confidence-error correlation
  #
  #   ranking_weight: 0.50→0.70 (Nov 15)
  #     Goal: Correct signal prioritization with pairwise margin losses
  #     Validation: Block 1-3 pass rates >95% on edge cases
  #     Result: 0.70 balances ranking with other objectives without saturating
  #
  #   mse_weight: 0.30→0.20→0.15 (Nov 19 FIX: OUTPUT COMPRESSION, NORMALIZED)
  #     Goal: Absolute priority accuracy (complement ranking)
  #     Issue (Nov 19): Predictions compressed to 69% of target range [0.08, 0.77] vs [0.11, 0.95]
  #     Root cause: MSE pulls toward safe zone (min error), outweighs calibration (weight 0.20 vs 0.50)
  #     Solution: Keep primary weights normalized to 1.0, increase calib_weights relative to primary
  #     Primary total: 0.70 + 0.15 + 0.15 = 1.0 (well-balanced core loss)
  #     Calibration weights: 2× primary weights for dominant expansion signal
  #
  #   uncertainty_weight: 0.12→0.25 (Nov 19 22:45 FIX: CORRELATION LOSS)
  #     Nov 13 increased 3.5× to 0.35 → exploding gradients (Grad=28.9)
  #     Nov 15 reduced to 0.10 (conservative)
  #     Nov 19: Restore to 0.12 but added correlation penalty to loss
  #     Nov 19 22:45: Increased to 0.25 with new correlation-based loss function
  #
  #   Expected performance (epoch 50):
  #   - Block 1-3: PASS (signal ordering: ranking 0.70 dominates)
  #   - Block 4: FIXED via calib weights 2-2.5× primary (range expansion while maintaining ordering)
  #   - Block 5: FIX with correlation penalty in uncertainty loss (target corr >= 0.15)
  ranking_weight: 0.80                    # Pairwise signal ordering margin (INCREASED - target 0.85+ accuracy)
  mse_weight: 0.05                        # Absolute priority accuracy (reduced to prioritize ranking)
  uncertainty_weight: 0.15               # Confidence-error correlation (reduced for ranking focus)
  use_snr_weighting: true                 # Weight losses by SNR
  loss_scale_factor: 0.002                # Scale factor for loss terms (from Nov 12 fix)
  
  # --- UNCERTAINTY CALIBRATION (NEW - Nov 13 fix) ---
  uncertainty_lower_bound: 0.01           # Prevent uncertainty collapse
  uncertainty_upper_bound: 0.50           # Prevent uncertainty explosion
  uncertainty_bounds_weight: 0.05         # Penalty weight for bounds violations
  
  # --- PREDICTION SATURATION FIX (NEW - Nov 13, UPDATED Nov 15 DEEP FIX) ---
  # TUNING METHODOLOGY (Nov 13-15, 2025):
  #   Issue: Predictions compressed to 11% of target range (output [0.506, 0.590] vs target [0.180, 0.950])
  #   Root causes: (1) Affine gains initialized too conservatively, (2) Penalty weights spread too thin
  #                (3) Bounds too restrictive, (4) Min variance not enforced
  #
  #   Calibration weight tuning (Nov 15 DEEP FIX):
  #   - calib_mean_weight: 0.20→0.30 (increased alignment penalty)
  #   - calib_max_weight: 1.50→1.00→0.50 (reduced from aggressive 1.50; overlaps naturally compress range)
  #   - calib_range_weight: 1.00→0.75→0.40 (reduced; let network expand on single-signal cases)
  #   
  #   Affine bounds tuning (Nov 15 DEEP FIX):
  #   - Gain: 1.2→2.5 (was 0.7→1.5, 1.67× smaller; now allows 2.5x expansion)
  #   - Bias: -0.2→+0.05 (was -0.1→+0.1, shifted down to give expansion room)
  #   
  #   Key insight: Small values (0.01-0.1 range) create flat loss landscapes when distributed
  #   across 1000+ parameters. Ratio-based penalties create consistent gradients regardless of scale.
  #   Minimum variance penalty (10×) prevents collapse: pred_std must stay >0.5×target_std
  #
  #   Expected improvement (Nov 15): Compression 11% → 90%+ by epoch 5, MAE 0.074 → 0.02 by epoch 15
  #
  # Nov 19 FIX: Balanced calibration weights (2× primary weights)
  #   - Output compression was 69% (predictions 0.767 vs target 0.950)
  #   - Root cause: MSE weight 0.20 outweighed calib weight 0.50 in gradient battle
  #   - Solution: Normalize primary weights to 1.0, make calib weights 2-2.5× primary strength
  #   - Calibration weight formula: calib_weight = 2.0-2.5 × mse_weight (0.15)
  #   - Effect: Dominant but balanced signal to expand predictions to full [0, 1] range
  output_bias_init: 0.45                  # Initialize output bias to 0.45 (slightly below mean)
  output_weight_std: 0.10                 # Weight std (2x standard for stronger gradients)
  calib_mean_weight: 0.30                 # Mean alignment: 2× mse_weight (0.15 × 2)
  calib_max_weight: 0.40                  # Max expansion: 2.67× mse_weight (0.15 × 2.67) - CRITICAL for ceiling
  calib_range_weight: 0.40                # Range expansion: 2.67× mse_weight (0.15 × 2.67) - CRITICAL for variance
  affine_gain_min: 1.2                    # Gain lower bound (prevent collapse)
  affine_gain_max: 2.5                    # Gain upper bound (allow aggressive expansion)
  affine_bias_min: -0.2                   # Bias lower bound (push floor down)
  affine_bias_max: 0.05                   # Bias upper bound (prevent floor rise)
  
  # --- GRADIENT MANAGEMENT ---
  gradient_clip_norm: 5.0                 # ⬆️ Increased from 2.0 (too aggressive for 6 loss components)
  gradient_log_threshold: 0.5             # Threshold for gradient norm logging
  
  # --- LABEL SMOOTHING ---
  label_smoothing: 0.0
  
  # --- ATTENTION/MODAL FUSION ---
  use_modal_fusion: true                 # Enable multi-modal attention fusion
  attention_num_heads: 8
  attention_dropout: 0.15
  
  # --- OVERLAP HANDLING ---
  overlap_use_attention: true             # Use attention for overlap encoding
  overlap_importance_hidden: 32           # Hidden dim for importance network




# ==============================================================================
# NEURAL POSTERIOR ESTIMATION (Flow-based parameter inference)
# ==============================================================================
neural_posterior:
   
  # --- PARAMETERS (11-dimensional parameter space) ---
  param_names:
    - mass_1                              # Primary mass
    - mass_2                              # Secondary mass
    - luminosity_distance                 # Distance to source
    - ra                                  # Right ascension
    - dec                                 # Declination
    - theta_jn                            # Inclination angle
    - psi                                 # Polarization angle
    - phase                               # Coalescence phase
    - geocent_time                        # Time at geocenter
    - a1                                  # Primary spin magnitude
    - a2                                  # Secondary spin magnitude
  
  # --- ARCHITECTURE (auto-adjusted by flow_type) ---
  context_dim: 768                        # ⬆️ Increased from 512 (50% more capacity for overlapping signals)
  max_iterations: 5                       # Max adaptive refinement iterations
  
  # --- FLOW TYPE (UNIFIED CONTROL) ---
  flow_type: "flowmatching"                                 # ✅ MUST MATCH CHECKPOINT ARCHITECTURE
  #                                        # Options: 'flowmatching', 'realnvp', 'nsf'
  #                                        # ⚠️ CRITICAL: Flow architectures are NOT interchangeable
  #                                        # - FlowMatching: Vector field regression (ODE-based, simulation-free CFM)
  #                                        # - NSF: Spline-based transforms (monotonic rational-quadratic splines)
  #                                        # Different layer structures, weight shapes, parameterizations
  #                                        # Checkpoint compatibility: ONLY with matching flow_type
  #                                        # 
  #                                        # CHOICE DECISION (Nov 15, 2025):
  #                                        # Using NSF because:
  #                                        #   1. Existing checkpoint trained with NSF (re-using weights)
  #                                        #   2. NSF faster convergence for 9D posterior (splines naturally model monotonic transforms)
  #                                        #   3. No ODE solver approximation errors (monotonic by construction)
  #                                        #
  #                                        # If switching to FlowMatching:
  #                                        #   - MUST retrain from scratch (checkpoint incompatible)
  #                                        #   - Remove checkpoint loading code
  #                                        #   - Expect 20%+ longer training time
  #                                        #   - Better for unbounded spaces (not applicable here)
  
  # --- NORMALIZING FLOW (NSF vs FlowMatching vs RealNVP) ---
  flow_config:
    # Neural Spline Flow (NSF): RECOMMENDED
    #   - Monotonic rational quadratic splines (invertible by construction)
    #   - No ODE solver approximation errors
    #   - Better for bounded parameter spaces
    #   - Expected NLL: 4-5 bits by epoch 10 (vs FlowMatching 8+ bits)
    # 
    # FlowMatching (OT-CFM): velocity-based, ODE solver approximation
    # RealNVP: coupling blocks, many layers for expressiveness
    
    # ✅ NSF CONFIG (OPTIMAL FOR 9D POSTERIOR)
    num_layers: 12                        # Fewer layers than FlowMatching (splines are more expressive)
    hidden_features: 512                  # Moderate hidden dim (splines naturally model monotonic transforms)
    num_bins: 16                          # Spline resolution - controls piecewise continuity
    tail_bound: 3.0                       # Auto-handles extreme tails (handles [-∞, ∞])
    dropout: 0.1                          # Dropout for stability
    
    # (Ignored for NSF - kept for backward compat with other flow types)
    solver_steps: 50                      # Only for FlowMatching
    num_blocks_per_layer: 2               # Only for RealNVP
  
  # --- EVENT-TYPE-SPECIFIC CONFIGURATION (Nov 13 enhancement) ---
  event_type: "BBH"                       # Options: BBH, BNS, NSBH (used for physics-informed priors)
  enable_event_specific_priors: true      # Use physics-informed priors per event type
  
  # --- TRAINING ---
  # learning_rate: 1.0e-5                  # ⬇️ FURTHER REDUCED from 2.5e-5 (prevent oscillations at convergence) - Nov 14
  learning_rate: 5.0e-5
  batch_size: 64                          # ⬆️ INCREASED to 64 (better gradient estimates for deep flow)
  epochs: 100                              # ⬆️ INCREASED from 30 to allow deep flow to converge
  patience: 15                            # ⬆️ INCREASED from 10 (monitor through epoch 20-30)
  weight_decay: 1.5e-5                   # ⬆️ SLIGHTLY increased (better regularization for large model)
  gradient_clip: 5.0                       # ⬇️ TIGHTER clipping (prevent exploding gradients) - Nov 14: reduced 10→5
  optimizer: "AdamW"
  
  # --- WARMUP (NEW - Nov 14: prevent divergence from large LR) ---
  warmup_epochs: 8                        # ⬆️ INCREASED from 5 (slower ramp for 10-layer deep flow)
  warmup_start_factor: 0.001               # ⬆️ INCREASED to 0.01 (faster ramp from conservative start)
  
  # --- LEARNING RATE SCHEDULER ---
  scheduler: "ReduceLROnPlateau"
  scheduler_patience: 8
  scheduler_factor: 0.6
  min_lr: 1.0e-6
  
  # --- PHYSICS LOSS (Nov 14 FIX: NLL is 24+ bits, flow not learning) ---
  # ⚠️ ROOT CAUSE: Old checkpoint with wrong architecture + physics loss preventing learning
  # Solution: Soft guidance strategy with strong flow regularization
  # TUNING METHODOLOGY (Nov 13-15, 2025):
  #   Ablation study on overlapping signal posterior estimation:
  #   - physics_loss_weight: 0.0→0.05→0.02
  #     Goal: Soft guidance without overwhelming NLL signal (~1% of total loss magnitude)
  #     Result: 0.02 allows NLL to improve from 12.1→8.3 bits by epoch 15
  #   - bounds_penalty_weight: 0.1→0.5→0.8  
  #     Goal: Prevent ground-truth parameter violations (secondary signals in overlaps)
  #     Validation: Reduces physics loss violations from 70%→<5% on validation set
  #     Result: 0.8 strong enough to constrain outputs without gradient starvation
  #   - sample_loss_weight: 0.0→0.1→0.2
  #     Goal: Flow regularization to prevent posterior collapse
  #     Result: 0.2 balances exploration vs exploitation in parameter space
  #   Expected convergence: NLL <4 bits by epoch 50, train-val gap <2
  # ⚠️ EXPERIMENTAL: These values are subject to further tuning based on actual convergence
  
  physics_loss_weight: 0.02                # Soft guidance (~1% of total loss)
  bounds_penalty_weight: 0.8               # Strong ground-truth constraints
  sample_loss_weight: 0.2                  # Flow regularization
  
  # --- JACOBIAN REGULARIZATION ---
  jacobian_reg_weight: 0.001              # Flow weight regularization (10x default)
  
  # --- DATA AUGMENTATION ---
  data_augmentation:
    enabled: true
    noise_scaling: [0.98, 1.02]          # Noise level variation
    time_shifts: [-0.002, 0.002]         # Time shift range (seconds)
    apply_probability: 0.3               # Probability of augmentation


# ==============================================================================
# ADAPTIVE SUBTRACTION (Signal removal for overlaps)
# ==============================================================================
adaptive_subtractor:
  complexity_level: "medium"              # low, medium, high
  waveform_approximant: "IMRPhenomPv2"   # Waveform model
  post_newtonian_order: "3.5PN"          # PN order for waveforms
  
  # --- PHYSICS ---
  spin_effects: true                      # Include spin effects
  tidal_effects: true                     # Include tidal effects
  
  # --- SUBTRACTION STRENGTH ---
  base_strength: 0.1                      # Base subtraction strength
  max_strength: 0.8                       # Maximum strength
  uncertainty_threshold: 0.3              # Uncertainty threshold for adaptation
  match_threshold: 0.7                    # Match threshold for acceptance


# ==============================================================================
# REINFORCEMENT LEARNING CONTROLLER (Adaptive complexity)
# ==============================================================================
rl_controller:
  enabled: true
  
  # --- STATE ---
  state_features:
    - remaining_signals
    - residual_power
    - current_snr
    - extraction_success_rate
  
  # --- COMPLEXITY LEVELS ---
  complexity_levels: ["low", "medium", "high"]
  complexity_configs:
    low:
      flow_layers: 4
      inference_samples: 500
    medium:
      flow_layers: 8
      inference_samples: 1000
    high:
      flow_layers: 14
      inference_samples: 2000
  
  # --- LEARNING ---
  learning_rate: 1.0e-3
  epsilon: 0.1                            # Exploration rate
  epsilon_decay: 0.995
  memory_size: 10000
  batch_size: 32


# ==============================================================================
# BIAS CORRECTION NETWORK (Systematic error correction)
# ==============================================================================
bias_corrector:
  enabled: true   # Enabled: trained after Neural PE converges on validation set
                  # Uses actual 768D context embeddings from context encoder
                  # Learns to correct systematic biases in parameter predictions

  # --- ARCHITECTURE (IMPROVED - Nov 20) ---
  hidden_dims: [256, 128, 64]
  context_dim: 768                         # ✅ MATCHES context encoder output (from neural_posterior.context_dim)
  dropout: 0.15                            # ⬆️ Increased from 0.10 (regularization)
  
  # --- NETWORK CAPACITY (Nov 20 UPGRADE) ---
  # Increased model capacity 2.6× to handle small 97-sample dataset with proper regularization
  # Embedding dims: 64→256 (4× larger)
  # Transformer d_model: 96→256 (2.67× larger), num_layers: 3→4
  # Head dims: 96→256 (2.67× larger)
  # Total params: ~0.4M → ~1.1M (275% increase)
  # Justification: Bias corrections are fundamentally harder than classification (uncertainty critical)
  # Larger model forces richer parameter representation despite small dataset

  # --- TRAINING (IMPROVED - Nov 20) ---
  learning_rate: 2.0e-4                  # ⬆️ Doubled from 1e-4 (larger capacity needs stronger learning)
  batch_size: 32                          # ⬆️ Increased from 16 (better batch statistics, stable norms)
  epochs: 50                              # ⬆️ Increased from 30 (larger model needs more training)
  patience: 20                            # ⬆️ Increased from 10 (tolerance for variance with small dataset)
  
  # --- LOSS FUNCTION (NEW - Nov 20) ---
  # Multi-component loss for stable learning on small dataset:
  # - NLL (0.50): Likelihood-based, robust to outliers
  # - Relative Error (0.30): Forces model to learn correction magnitudes
  # - Uncertainty Entropy (0.15): Encourages proper uncertainty estimates
  # - Quality Weighting (0.05): Emphasize high-quality signals
  loss_components:
    nll_weight: 0.50
    relative_error_weight: 0.30
    entropy_weight: 0.15
    quality_weight: 0.05


# ==============================================================================
# DATASET CONFIGURATION
# ==============================================================================
data:
  # --- SAMPLING ---
  sample_rate: 4096                       # Hz
  segment_duration: 4.0                   # seconds
  
  # --- FREQUENCY RANGE ---
  f_low: 20.0                             # Hz (low frequency cutoff)
  f_high: 1024.0                          # Hz (high frequency cutoff)
  
  # --- SPLITS ---
  validation_split: 0.15                  # Validation fraction
  test_split: 0.05                        # Test fraction


# ==============================================================================
# MONITORING & OUTPUT
# ==============================================================================
monitoring:
  save_frequency: 5                       # Save checkpoint every N epochs
  log_frequency: 1                        # Log metrics every N epochs
  early_stopping: true
  
  # --- METRICS TO TRACK ---
  metrics:
    - nll_loss
    - parameter_accuracy
    - extraction_efficiency
    - train_val_gap
    - gradient_norm
  
  # --- RL MONITORING ---
  rl_monitoring:
    track_complexity_changes: true
    log_rl_rewards: true
    complexity_distribution: true
  
  # --- BIAS CORRECTION MONITORING ---
  bias_monitoring:
    track_correction_effectiveness: true
    log_physics_violations: true

output:
  save_best_only: true                    # Save only best checkpoint
  save_intermediate: true                 # Save intermediate checkpoints
  generate_plots: true                    # Generate training plots


# ==============================================================================
# VALIDATION FLAGS (True/False Summary)
# ==============================================================================
# These flags are logged during training startup for debugging:
#
# PRIORITY NET:
#  ✓ use_strain: true (temporal strain encoder enabled)
#  ✓ use_edge_conditioning: true (edge-type embedding enabled)
#  ✓ use_transformer_encoder: true (legacy flag, not used in current code)
#  ✓ use_snr_weighting: true (SNR-weighted loss enabled)
#  ✓ use_modal_fusion: true (multi-modal attention fusion enabled)
#  ✓ attention_num_heads: 8 (number of attention heads in modal fusion)
#  ✓ attention_dropout: 0.15 (dropout in attention layers)
#  ✓ overlap_use_attention: true (attention-weighted pairwise overlap analysis)
#  ✓ overlap_importance_hidden: 32 (hidden dim for overlap importance network)
#  ✓ early_stopping: true
#  ✓ label_smoothing: 0.02
#
# NEURAL POSTERIOR:
#  ✓ data_augmentation.enabled: true
#
# ADAPTIVE SUBTRACTION:
#  ✓ spin_effects: true
#  ✓ tidal_effects: true
#
# RL CONTROLLER:
#  ✓ enabled: true
#  ✓ track_complexity_changes: true
#  ✓ log_rl_rewards: true
#
# BIAS CORRECTOR:
#  ✓ enabled: true
#  ✓ track_correction_effectiveness: true
#  ✓ log_physics_violations: true
#
# OUTPUT:
#  ✓ save_best_only: true
#  ✓ save_intermediate: true
#  ✓ generate_plots: true
